# 苍穹缓存机制

## 缓存是什么

> 缓存就是在插件之间或者在插件内部实现参数传递的最简单的方法。我们可以用缓存机制来实现非常丰富、复杂的功能。

举一个简单的例子：假如有插件A和插件B，插件B在A插件执行完后执行，B想读取A产生的结果。如果用传统的办法可以将A的结果赋值给一个不可见的控件，然后轮到B执行的时候，从这个控件进行读取。

这样做存在几个问题：

1. 书写的逻辑不够通畅，需要一个冗余无用的字段
2. 如果两个插件在不同的页面里使用，那么此方法失效

所以如果要在两个插件或者不同页面之间进行传参，一个最简单直接的方式就是用苍穹自带的Redis缓存来进行传参处理。

## 如何使用缓存

[教程引导](https://vip.kingdee.com/article/272106526062528512?productLineId=1&isKnowledge=2&lang=zh-CN)

代码模板：

1. 拿到缓存

```java
// 拿到缓存，命名为cache（固定的写法）
DistributeSessionlessCache cache = CacheFactory.getCommonCacheFactory().getDistributeSessionlessCache("customRegion");
```

2. 往缓存里面放入东西

```java
// 使用put方法，前者是你想命名的名字，后者是你想放入的字符串信息
cache.put("yourValName", yourString);
```

3. 从缓存里面取出东西

```java
// 使用get方法，括号内写入之前你命名的变量名
yourString = cache.get("yourValName");
```

## 实例演示

在这里选用一个我们的产品华科智慧图书馆中一个最为复杂的功能 - - 读书笔记来为大家演示缓存的使用。

部分代码：

```java
public class ReadGpt extends AbstractFormPlugin implements Plugin {
    private final String htmlCode1 = "在这里省略";
    private final String htmlCode2 = "在这里省略";
    private String bookName;
    @Override
    public void registerListener(EventObject e) {
        super.registerListener(e);
        // 添加按钮监听
        Button button1 = this.getView().getControl("myg6_startread");
        Button button2 = this.getView().getControl("myg6_conclude");
        Button button3 = this.getView().getControl("myg6_keyword");
        Button button4 = this.getView().getControl("myg6_showai1");
        Button button5 = this.getView().getControl("myg6_showai2");
        Button button6 = this.getView().getControl("myg6_showai3");
        Button button7 = this.getView().getControl("myg6_forward");
        Button button8 = this.getView().getControl("myg6_backward");
        // 监听
        button1.addClickListener(this);
        button2.addClickListener(this);
        button3.addClickListener(this);
        button4.addClickListener(this);
        button5.addClickListener(this);
        button6.addClickListener(this);
        button7.addClickListener(this);
        button8.addClickListener(this);
    }
    @Override
    public void click(EventObject evt) {
        super.click(evt);
        Object source = evt.getSource();
        
        // 取出一些前置必要信息
        String pageId = this.getView().getMainView().getPageId();
        
        // 获取图书名字
        DynamicObject book = (DynamicObject) this.getModel().getValue("myg6_bookname");
        bookName = book.getString("name");
        
        // 获取缓存
        DistributeSessionlessCache cache = CacheFactory.getCommonCacheFactory().getDistributeSessionlessCache("customRegion");
        
        // 开始书写按钮的业务逻辑
        if (source instanceof Button) {
            Button button = (Button) source;
            String key = button.getKey();
            // 若是渲染界面按钮
            if (StringUtils.equals("myg6_startread", key)) {
                // 处理字符串给缓存
                solve();
                // 将当前pageId 标记为第0面
                cache.put("pageId", "0");
                render(0);
            }
            // 若是前进后退按钮
            if (StringUtils.equals("myg6_forward", key)) {
                String pg = cache.get("pageId");
                int pgInt = Integer.parseInt(pg) + 1;
                String nxtPg = String.valueOf(pgInt);
                if (StringUtils.equals(nxtPg, cache.get("allpage"))) {
                    this.getView().showMessage("已经是最后一页了");
                    return;
                }
                cache.put("pageId", nxtPg);
                render(pgInt);
            } else if (StringUtils.equals("myg6_backward", key)) {
                String pg = cache.get("pageId");
                int pgInt = Integer.parseInt(pg) - 1;
                if (pgInt < 0) {
                    this.getView().showMessage("已经是第一页了");
                    return;
                }
                cache.put("pageId", String.valueOf(pgInt));
                render(pgInt);
            } else {
                // 限于篇幅，省略其他功能部件
            }
        }
    }
    private void render(int page) {
        // 获取缓存
        DistributeSessionlessCache cache = CacheFactory.getCommonCacheFactory().getDistributeSessionlessCache("customRegion");
        
        for (int i = 1; i <= 3; ++i) {
            // 获取当前页的文字内容
            String txtid = "txt" + (i + page * 3);
            String txtContent = cache.get(txtid);
            if (txtContent == null) {
                // 填入html信息
                String htmlId = "myg6_txt" + i;
                Html html = this.getView().getControl(htmlId);
                html.setConent("");
                break;
            }
            // 组装成html代码
            String htmlCode = htmlCode1 + txtContent + htmlCode2;
            // 填入html信息
            String htmlId = "myg6_txt" + i;
            Html html = this.getView().getControl(htmlId);
            html.setConent(htmlCode);
        }
    }
    private void solve() {
        // 获取缓存
        DistributeSessionlessCache cache = CacheFactory.getCommonCacheFactory().getDistributeSessionlessCache("customRegion");
        
        QFilter qFilter = new QFilter("myg6_bookname", QCP.equals, bookName);
        DynamicObject booktxt = BusinessDataServiceHelper.loadSingle("myg6_txts", new QFilter[]{qFilter});
        String s = booktxt.getString("myg6_largetextfield_tag");
        // 去掉字符串中的回车符
        s = s.replace("\n", "").replace("\r", "");
        int all = 0, i = 0, idx = 0; // all为总页数，i为字符开始下标，idx为当前填入的txt缓存号
        int chunk = 310; // 310为上限
        while (i < s.length()) {
            int ed = i + chunk;
            if (ed >= s.length()) {
                ed = s.length();
            }
            while (ed > i && s.charAt(ed - 1) != '。' && s.charAt(ed - 1) != '？' && s.charAt(ed - 1) != '.' && s.charAt(ed - 1) != '?' && s.charAt(ed - 1) != '!' && s.charAt(ed - 1) != '！') {
                --ed;
            }
            if (ed == i) { // 没找到句号或问号，防止死循环
                ed = Math.min(i + chunk, s.length());
            }
            String txtContent = s.substring(i, ed);
            cache.put("txt" + (++idx), txtContent);
            i = ed;
            ++all;
        }
        all = (all + 2) / 3;
        // 放入总页数
        cache.put("allpage", String.valueOf(all));
    }
}
```

这个代码中，实现了读书笔记的基础功能：渲染文字到当前三块页面，然后实现前后翻页的功能。

整体项目的[github仓库](https://github.com/llxler/Smart-Library)